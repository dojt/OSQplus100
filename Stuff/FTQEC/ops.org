#+TITLE:  Encyclopedia of Stabilizer Code Operations
#+DATE:   Thu May 23 18:10:10 EEST 2024
#+SETUPFILE: ./org-mode-header.org
:SET_STUFF_UP:
#+INCLUDE: "~/Git/DOT_LaTeX/org-latex-export-defs.org"
#+STARTUP: overview
#+SEQ_TODO: TODO MORE ↘️ ARGH | REVIEW NEW
#+BEGIN_HTML
\(
\newcommand{\sodifjosidjfosidjfosijdfosijdfoisjdfoijsdofijsodifjosidjfosidj}{\mathscr{A}}
\newcommand{\viusbidufhwiefsdofijsoifjaoidsjfoiqhwoeufhaosudfhoauisdhfoaiwe}[1]{A #1}
\)
#+END_HTML
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+BEGIN_COMMENT
❗️ *WARNING!  GPLv3*
#+END_COMMENT
#+PROPERTY: header-args :eval never :exports code :noweb no-export :noweb-prefix no
:END:

* Lattice Surgery
** ↘️ Code
***** Shapes

      * Textbook shape d=7: 7×7 physical qubits
        #+BEGIN_EXAMPLE
         ∧ ∧ ∧
         XZXZXZ⟩
        ⟨ZXZXZX
         XZXZXZ⟩
        ⟨ZXZXZX
         XZXZXZ⟩
        ⟨ZXZXZX
          ∨ ∨ ∨
        #+END_EXAMPLE

      * (more)

***** MORE "Logical contributions" of physical qubit neighborhoods

      * In the bulk: 1-(1/4+1/4+1/4+1/4)                      = 0
        #+BEGIN_EXAMPLE
        Z X
         ⊙
        X Z
        #+END_EXAMPLE

      * On an edge: 1-(1/4+1/4+1/2)                           = 0
        #+BEGIN_EXAMPLE
        X
         ⊙
        Z ⟩
        #+END_EXAMPLE

      * Convex corner std Z-X: 1-(1/4+1/2)                    = 1/4
        #+BEGIN_EXAMPLE
        ∧   ∧
         ⋅ ⋅ ⊙
        Z X Z
         ⋅ ⋅ ⋅
        X Z X ⟩
        #+END_EXAMPLE

      * Convex corner weird 𝛔-𝛔:  1-(1/4+1/2+1/2)             = -1/4
        #+BEGIN_EXAMPLE
        ∧   ∧
         ⋅ ⋅ ⊙
        Z X Z ⟩
         ⋅ ⋅ ⋅
        X Z X
         ⋅ ⋅ ⋅
        Z X Z ⟩
        #+END_EXAMPLE

      * Convex corner obtuse 𝛔-𝛔 near:  3 − 2⋅(1/2+1/4+1/3) − (1/4+1/4+1/4+1/3)  = -1/4
        #+BEGIN_EXAMPLE
          ∧
         ⋅ ⊙
        Z X ◺
         ⋅ ⊙ ⊙
        X Z X ⟩
         ⋅ ⋅ ⋅
        Z X Z
        #+END_EXAMPLE

      * Convex corner obtuse 𝛔-𝛔 far:  3 − 2⋅(1/4+1/3) − (1/4+1/4+1/4+1/3)  = 3/4 = SHIT
        #+BEGIN_EXAMPLE
        ∧
         ⋅ ⊙
        Z X ◺
         ⋅ ⊙ ⊙
        X Z X
         ⋅ ⋅ ⋅
        Z X Z ⟩
        #+END_EXAMPLE

      * Convex corner obtuse Z-X:  3 − (1/2+1/4+1/3) − (1/4+1/3) − (1/4+1/4+1/4+1/3) = 1/4
        #+BEGIN_EXAMPLE
          ∧
         ⋅ ⊙
        Z X ◺
         ⋅ ⊙ ⊙
        X Z X
         ⋅ ⋅ ⋅
        Z X Z ⟩
        #+END_EXAMPLE

      * etc
      * etc


** TODO Memory
*** TODO Syndrome measurement

      * TODO :: Measurement circuits for single code block.  This is the question: How can you squeeze the
        measurement of all stabilizer generators into a quantum circuit that's as shallow as possible?

      * TODO :: Maybe?  Measurement circuits for two code blocks that are close together; see [[»Close Shave«]]
        implementation of [[Split]] below.

*** Decoding

      * (Current) standard work is "Sparse Blossom"[fn:SparseBlossom]

*** Fixing


** ↘️ Shape changes & moves
***** TODO Expand
***** MORE Split

      * Definitions
        - X-split = |++⟩⟨+| + |--⟩⟨-|  = (|00⟩+|11⟩)⟨0| + (|01⟩+|10⟩)⟨1|  ⫽√2
          + ZX-diagram
            #+BEGIN_EXAMPLE
               ╱
             ─X
               ╲
            #+END_EXAMPLE
        - Z-split = |00⟩⟨0| + |11⟩⟨1|
          + ZX-diagram
            #+BEGIN_EXAMPLE
               ╱
             ─Z
               ╲
            #+END_EXAMPLE

      * Implementation 1: /»Close Shave«/  <<»Close Shave«>>
        + Measurement pattern
          1. Center part of logical qubit, boundaries left and right, not shown, are Z; logX is vertical X's:
            #+BEGIN_EXAMPLE
            ∧   ∧   ∧
             ⋅ ⋅ ⋅ ⋅ ⋅
            Z X 𝗭 X Z
             ⋅ ⋅ ⋅ ⋅ ⋅
            X Z 𝗫 Z X
             ⋅ ⋅ ⋅ ⋅ ⋅
            Z X 𝗭 X Z
             ⋅ ⋅ ⋅ ⋅ ⋅
            X Z 𝗫 Z X
             ⋅ ⋅ ⋅ ⋅ ⋅
              ∨   ∨
            #+END_EXAMPLE
          2. Measure Z⊗Z (vertical) on the left of each of the bold 𝗭s (the pairs on the right are implied).
          3. Result: 𝛕 := tensor of all X's left and right of the removed stabilizer column; plus:
            #+BEGIN_EXAMPLE
            ∧        ∧
             ⋅ ⋅  ⋅ ⋅ ⋅
            Z X ⟩⟨ X Z
             ⋅ ⋅  ⋅ ⋅ ⋅
            X Z    Z X
             ⋅ ⋅  ⋅ ⋅ ⋅
            Z X ⟩⟨ X Z
             ⋅ ⋅  ⋅ ⋅ ⋅
            X Z    Z X
             ⋅ ⋅  ⋅ ⋅ ⋅
              ∨    ∨
            #+END_EXAMPLE
            So we have 2 logical qubits, but their logical X's are equivalent through 𝛕

      * TODO :: Implementation 2: As in[fn:river]

      * Differences between Implementations 1 & 2:
        + In #2, two rows/columns of stabilizers — i.e., a whole row of data qubits — are measured out, while in
          #1, only one row/column of stabilizers is measured out, and no individual data qubits are measured.
        + TODO :: In #1, if you use measurement qubits, the same measurement qubit is used for two different code
          blocks (left and right) after the split.  This makes it more difficult (TODO: Impossible??) to squeeze
          the stabilizer measurements into an as-shallow-as-possible circuit.  This probably makes the
          Implementation 1 [[»Close Shave«]] simply silly.

***** TODO Merge

      * Definitions (with ZX-diagrams)
        + Merges have a classical outcome, 𝖺, so they reduce the quantum degrees of freedom from 2 to 1
        + Z-merge = |0⟩⟨0𝖺| + |1⟩⟨1𝖺̅|
          #+BEGIN_EXAMPLE
          ───┐
             Z─
          ─Xₐ┘
          #+END_EXAMPLE
        + X-merge = |+⟩⟨+𝑎| + |-⟩⟨-𝑎̅|  where 𝑎 = (-1)ᵃ, and 𝑎̅ = -(-1)ᵃ
          #+BEGIN_EXAMPLE
          ───┐
             X─
          ─Zₐ┘
          #+END_EXAMPLE
       * TODO :: Implementation with stabilizer picture

***** REVIEW Full rotate

      * Meaning: Z-boundary and X-boundary are exchanged.
        + ... but what happens with logical Z,X — are they kept?

      * Htrans + Hvirt :: Possibly in parallel:
        + Apply H to each data qubit (transversal [[H-gate]])
        + Swap Z,X logical ops (virtual [[H-gate]])

***** TODO FoGi rotate

      From [fn:FoGi]

***** TODO etc


** ↘️ Operations
*** ↘️ State preparation
***** MORE ±Z, ±X

      * +𝛔 where 𝛔 ∈ {Z,X}:
        #+BEGIN_SRC python
          for q in dataqubits:
              q.init(+𝛔)
          EC(d times)
        #+END_SRC
        Cost:
        + 1 QEC cycle
          - ... that can be merged with next op[fn:river]
          - TODO :: how exactly?

      * TODO :: There's sure to be a shortcut for preparing -Z and -X

***** TODO ±Y

*** MORE Single qubit Clifford gates
***** REVIEW Pauli-{X,Z} gates

      * Transversal :: (Only if length of observable is odd)[fn:river]
        + Space-time cost: Time = 1 cycle
        + Error cost:
          - *Z*: with /virtual/ Z-gate: 0
          - *X*, *Z* w/o virtual Z-gate: loads of 1-qubit gates

      * Virtual P   :: Flip /frame/ of every physical qubit & *propagate*
        - ??? This doesn't look like it makes any sense...

      * Virtual L   :: Flip sign of logical op[fn:river]

***** Pauli-Y gate

      * Transversal :: (Only if lengths of Z,X observables are both odd)[fn:river]

      * Apply ➛Z➛X➛ or ➛X➛Z➛; e.g., ~X{virt}, Ztrans~
        - difference is global phase
        - can be done in parallel

***** REVIEW H-gate

      * Transversal :: (TODO explain)

      * Virtual :: Swap Z,X logical ops
        + I.e., say,
          - before: Z̅ between Z-boundaries, X̅  between X-boundaries;
          - after:  Z̅ between X-boundaries, X̅  between Z-boundaries.
        + Cf. [[Full rotate]]

*** ↘️ Single-qubit measurement
***** ARGH Z,X

      * Destructive :: Measure all data qubits.[fn:river]
        + TODO :: Question: How to handle error detecting info that arises?
        + TODO :: Write pseudocode

      * Slicing off ::  (Trivial) 𝞂-[[Split]] then 𝞂-basis measurement
        + Split off 1 column/row of weight-4 stabilizers (to measure 𝛔, do 𝛔 split)
          - In other words, [[Split]] qubit in two and perform destructive measurement of one of the 2 parts.
        + ZX-diagram (for measuring Z):
          #+BEGIN_EXAMPLE
           +-------+
           |       |
          ────Z──────
           |  │    |
           |  └─Xₐ |
           +-------+
          #+END_EXAMPLE
          - The ~─Xₐ~ measurement (i.e., ⦨Z) in the diagram can be performed on a trivial "logical qubit"
            consisting of only one row or column of data qubits, e.g.:
            #+BEGIN_EXAMPLE
               ∧
            ⋅ ⋅ ⋅        ⋅ ⋅  ⋅
             Z 𝗫          Z ⟩⟨
            ⋅ ⋅ ⋅        ⋅ ⋅  ⋅
             X 𝗭 ⟩        X    ⟩
            ⋅ ⋅ ⋅    ⇒   ⋅ ⋅  ⋅
             Z 𝗫          Z ⟩⟨
            ⋅ ⋅ ⋅        ⋅ ⋅  ⋅
             X 𝗭 ⟩        X    ⟩
            ⋅ ⋅ ⋅        ⋅ ⋅  ⋅
             ∨            ∨
            #+END_EXAMPLE
          - Remember that on the RHS there's an additional stabilizer from the split that's not part of any of the
            two logical qubits: the tensor product of the Z's of all the data qubits (10, in our case) on the
            deleted stabilizer column; the value of it is known (as it's the product of all bold plus one ~∧~
            Z-stabilizers in the logical qubit before the split, and it means that the Z-value on the left
            remaining logQ is up-to-sign the same as the Z-value of the right remaining (trivial) logQ.
        + ➾ each data qubit in single remaining column/row holds observable value up to sign
        + Careful: distance may decrease ([[Expand]] before?)
        + TODO :: Question: How to handle error detecting info that arises?  (The product of every 2 consecutive
          data qubits in the row/column is a stabilizer known.)

      * Slicing on :: 𝞂-stateprep + (trivial) 𝞂-[[Merge]]
        + ZX-diagram (for measuring Z):
          #+BEGIN_EXAMPLE
           +----------+
           |          |
          ──────────Z───
           | X₀───Xₐ┘ |
           +----------+
          #+END_EXAMPLE
        + The |0⟩ state preparation (~X₀─~ in ZX-diagram) can be a performed on a trivial logical qubit
          consisting of a single row/column.
          - ... or any size, really.
        + Interestingly, there's no destructive measurement anywhere in this approach.

*** 2-qubit Clifford gates
***** MORE CNOT

      * Z-split + X-merge + fix[fn:HFDM11] <<Z-split+X-merge>>
        + 'Fix' refers to fixing the effect of the measurement outcome "𝖺": a Z-gate has to be applied if that 𝖺=1.
        + ZX-diagram:
          #+BEGIN_EXAMPLE
           +--------+
           |        |
          ────Z──Zₐ───
           |  │     |
           |  │     |
           |  Zₐ    |
           |  │     |
          ────X───────
           |        |
           +--------+
          #+END_EXAMPLE
        + The vertical line in the ZX-diagram can be thought of as an auxiliary logical qubit.
        + Applying the Z-gate can be done virtually, of course.
        + TODO :: Split & merge can be done in parallel — TODO: *Work out how!*[fn:GiCNOT]
        + TODO :: Work out cost & compare with [[⦨ZZ+⦨XX]]
        + TODO :: Write pseudocode!

      * ⦨ZZ + ⦨XX + fix <<⦨ZZ+⦨XX>>
        + This is used in[fn:river]
        + ZX-diagram:
          #+BEGIN_EXAMPLE
           +--------------------+
           |                    |
          ───────Z─────────Zₑ─────
           |     │              |
           |     Xₐ             |
           |     │              |
           | Z₀──Z───X──Xₕ      |
           |         │          |
           |         Zₑ         |
           |         │          |
          ───────────X─────Xₐ₊ₕ───
           |                    |
           +--------------------+
          #+END_EXAMPLE
        + Don't forget: ~Z₀─~ is |+⟩ state prep (i.e., X-basis), and ~─Xₕ~ is Z-basis measurement.
        + Why is this correct? Use standard ZX-calculus!
        + TODO :: Work out cost & compare with [[Z-split+X-merge]]
        + TODO :: Write pseudocode!
        + TODO :: 🤔🤔🤔 On the level of elementary operations (Pasm) is this really different from
          [[Z-split+X-merge]]?

*** ↘️ Multi-qubit Pauli measurement
***** MORE Measure ZZ,XX

      * Z-split /then/ Z-merge
        + ZX-diagram for ⦨ZZ
          #+BEGIN_EXAMPLE
           +--------+
           |        |
          ───Z────────
           |  ╲     |
           |   ╲    |
           |    Xₐ  |
           |     ╲  |
          ────────Z───
           |        |
           +--------+
          #+END_EXAMPLE
        + I think this is the same as in[fn:FoGi]
        + TODO :: Write pseudocode!

      * Z-merge /then/ Z-split, plus fix
        + ZX-diagram for ⦨ZZ
          #+BEGIN_EXAMPLE
           +------------+
           |            |
          ──────┐  ┌──────
           |    │  │    |
           |    Z──Z    |
           |    │  │    |
          ───Xₐ─┘  └─Xₐ───
           |            |
           +------------+
          #+END_EXAMPLE
        + Why is this correct?  Transform ZX-diagram above ("1.") as follows:
          2. [@2]
             #+BEGIN_EXAMPLE
              +------------+
              |            |
             ──────Z─────────
              |    │       |
              |    │       |
              |    │       |
             ───Xₐ─Z────Xₐ───
              |            |
              +------------+
             #+END_EXAMPLE
          3.
             #+BEGIN_EXAMPLE
              +------------+
              |            |
             ──────Z─────────
              |    │       |
              |    Xₐ      |
              |    │       |
             ──────Z─────────
              |            |
              +------------+
             #+END_EXAMPLE
        + TODO :: Write pseudocode!



* Footnotes = Bibliography
** Necessary reading: Now

  1) Microsoft[fn:microsoft: ~arXiv:2211.07629~ /Assessing requirements to scale to practical quantum advantage/] *Source code = Where?!?*

  2) Riverlane[fn:river: ~arXiv:2307.03233~ /Compilation of a simple chemistry application/ (Riverlane)] *Source code = Where?!?*

  3) Lattice Surgery Compiler[fn:LaSuCom: ~arXiv:2302.02459~ /A High Performance Compiler for Very Large Scale Surface Code Computations./]  [[https://latticesurgery.com][latticesurgery.com]]  *Has a test suite!*

  4) Oak Ridge[fn:oak: ~arXiv:2311.10687~ /TISCC: A Surface Code Compiler and Resource Estimator for Trapped-Ion Processors/] *Includes verification!* [[https://github.com/ORNL-QCI/TISCC][github.com/ORNL-QCI/TISCC]]

** Necessary reading: Later

  5) [@5] Fowler-Gidney[fn:FoGi: ~arXiv:1808.06709~ /Low overhead quantum computation using lattice surgery/ Fowler & Gidney]

  6) Litinski /Game of Surface Codes/

  7) Other Litinski stuff, e.g., on magic states.

** Other references

  * HFDM11[fn:HFDM11: ~arXiv:1111.4022~ /Surface code quantum computing by lattice surgery./ Horsman, Fowler,
    Devitt, Meter] Keep in mind that this paper is about the un-rotated surface code.

  * Sparse Blossom[fn:SparseBlossom: ~arXiv:2303:15933~ /Sparse Blossom: Correcting a million errors per
        core second with minimum-weight matching./ Higgot & Gidney] [[https://github.com/oscarhiggott/PyMatching][github.com/oscarhiggott/PyMatching]]

** Online discussions

  * Gidney-QCSX-CNOT [fn:GiCNOT: Gidney's answer on Quantum-Computing Stackexchange,
    [[https://quantumcomputing.stackexchange.com/questions/20830/how-can-surface-codes-perform-splitting-and-merging-at-the-same-time-when-they-i]]]

  * [[https://quantumcomputing.stackexchange.com/questions/38232/deformation-rules-for-zx-pipe-diagrams][Gidney's reply to /Deformation rules for ZX-pipe diagrams/.]]  DOT: Read this!

** EOF
# Local Variables:
# fill-column: 115
# End:
