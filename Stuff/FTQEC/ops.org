#+TITLE:  Encyclopedia of Stabilizer Code Operations
#+AUTHOR:
#+DATE:   Thu May 23 18:10:10 EEST 2024
:SET_STUFF_UP:
#+OPTIONS: H:4
#+INCLUDE: "~/Git/DOT_LaTeX/org-latex-export-defs.org"
#+STARTUP: overview
#+STARTUP: latexpreview
#+SEQ_TODO: TODO MORE â†˜ï¸ ARGH | REVIEW NEW
#+BEGIN_HTML
\(
\newcommand{\sodifjosidjfosidjfosijdfosijdfoisjdfoijsdofijsodifjosidjfosidj}{\mathscr{A}}
\newcommand{\viusbidufhwiefsdofijsoifjaoidsjfoiqhwoeufhaosudfhoauisdhfoaiwe}[1]{A #1}
\)
#+END_HTML
#+LaTeX_HEADER: \newcommand{\sodifjosidjfosidjfosijdfosijdfoisjdfoijsdofijsodifjosidjfosidj}{\mathscr{A}}
#+LaTeX_HEADER: \newcommand{\viusbidufhwiefsdofijsoifjaoidsjfoiqhwoeufhaosudfhoauisdhfoaiwe}[1]{A #1}
#+LATEX_CLASS_OPTIONS: [a4paper,10pt,twoside,reqno,nonamelimits]
#+BIBLIOGRAPHY: "~/Git/DOT_LaTeX/dirks.bib"
#+CITE_EXPORT: csl
#+PROPERTY: header-args :eval never :exports code :noweb no-export :noweb-prefix no
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+BEGIN_COMMENT
â—ï¸ *WARNING!  GPLv3*
#+END_COMMENT
:END:

* MORE General Blah

      * When figuring out processes that modify a (bunch of) logical qubit(s) using initializations and
        measurements, /the trick is to track/ the logical ops, while making sure that the logical-qubit degrees of
        freedom are right (i.e., no bad stabilizers â€” there'll never be too few stabilizers if the
        logical-contribution arithmetic (see [["Logical contributions" of physical qubit neighborhoods]] below) is
        right).

      * ğŸ¤”ğŸ¤”ğŸ¤” :: Why do [fn:river] (Fig. 10) end the rotation with a /shrink/ and then move(swap) the patch one
        row down?  Instead, they could have completed the rotation "normally" (stabilizer measurements) and shrink
        away the top part of it, saving the move/swap step, no? ...?


* Lattice Surgery
** â†˜ï¸ Code
*** MORE Shapes
***** Textbook shape ğ‘‘=7: 7Ã—7 physical qubits
        + Stab-picture:
          #+BEGIN_EXAMPLE
           âˆ§ âˆ§ âˆ§
           XZXZXZâŸ©
          âŸ¨ZXZXZX
           XZXZXZâŸ©
          âŸ¨ZXZXZX
           XZXZXZâŸ©
          âŸ¨ZXZXZX
            âˆ¨ âˆ¨ âˆ¨
          #+END_EXAMPLE
        + Logical ops
          - default Z = any straight vertical  line  (between Z-boundary and Z-boundary)
          - default X = any straight horizontal line (between X-boundary and X-boundary)

***** Textbook expansion (growing) leads to ğ‘‘Ã—ğ‘’ blocks, with both ğ‘‘,ğ‘’ odd and â‰¥3

***** The condition ğ‘‘,ğ‘’ odd can be dropped.  Then errors of weight ğ‘‘/2 or ğ‘’/2 can only be detected, not
        corrected.

***** Deformed rectangular :: See [fn:FoGi] Fig. 13, or [fn:river] Fig. 10(b).
        + See [[Skip 1 on an edge][Skip 1 on an edge]] in [["Logical contributions" of physical qubit neighborhoods]]
        + Note the weird possibilities for the logical ops.
        + In terms of Z/X-boundaries, the edge in the example is split between the part left of (or above) the skip
          â€” in the example, that's a Z-boundary â€” and the part right of (or below) the split â€” in the example,
          that's an X-boundary.

***** Non-rectangular :: See [fn:FoGi], figures 7,8,9,21.
        + Note: Fig. 7(b) has 1 logical qubit; Fig. 8(b) has 2 logical qubits.

***** What?!?? :: What is Fig. 9(b) in [fn:FoGi] ???

*** MORE "Logical contributions" of physical qubit neighborhoods
***** In the bulk :: 1-(1/4+1/4+1/4+1/4)                                             = 0
        #+BEGIN_EXAMPLE
        Z X
         âŠ™
        X Z
        #+END_EXAMPLE

***** On an edge :: 1-(1/4+1/4+1/2)                                                  = 0
        #+BEGIN_EXAMPLE
        X
         âŠ™
        Z âŸ©
        #+END_EXAMPLE

***** Skip 1 on an edge :: 1-(1/4+1/4)                                               = +1/2
        #+NAME: Skip 1 on an edge
        #+BEGIN_EXAMPLE
          âˆ§     âˆ§
         â‹… â‹… âŠ™ â‹… â‹…
        Z X Z X Z X
        #+END_EXAMPLE
        See Figs. 7,13 in [fn:FoGi]; Fig 10(b,c) in [fn:river]

***** Convex corner Z-X std :: 1-(1/4+1/2)                                           = +1/4
        #+BEGIN_EXAMPLE
        âˆ§   âˆ§
         â‹… â‹… âŠ™
        Z X Z
         â‹… â‹… â‹…
        X Z X âŸ©
        #+END_EXAMPLE

***** Convex corner ğ›”-ğ›” near :: 1-(1/4+1/2+1/2)                                      = -1/4
        #+NAME: Convex corner ğ›”-ğ›” near
        #+BEGIN_EXAMPLE
        âˆ§   âˆ§
         â‹… â‹… âŠ™
        Z X Z âŸ©
         â‹… â‹… â‹…
        X Z X
         â‹… â‹… â‹…
        Z X Z âŸ©
        #+END_EXAMPLE
        See Fig. 21 in [fn:FoGi]

***** Convex corner obtuse ğ›”-ğ›” near :: 3 âˆ’ 2â‹…(1/2+1/4+1/3) âˆ’ (1/4+1/4+1/4+1/3)       = -1/4
        #+NAME: Convex corner obtuse ğ›”-ğ›” near
        #+BEGIN_EXAMPLE
          âˆ§
         â‹… âŠ™
        Z X â—º
         â‹… âŠ™ âŠ™
        X Z X âŸ©
         â‹… â‹… â‹…
        Z X Z
        #+END_EXAMPLE
        See Figs. 7,8,9,13 in [fn:FoGi]; Fig 10(b) in [fn:river]

***** Convex corner ğ›”-ğ›” far :: 1-1/4                                                 = +3/4 = /B.S./
        #+BEGIN_EXAMPLE
          âˆ§
         â‹… â‹… âŠ™
        Z X Z
         â‹… â‹… â‹…
        X Z X âŸ©
         â‹… â‹… â‹…
        Z X Z
        #+END_EXAMPLE

***** Convex corner obtuse ğ›”-ğ›” far :: 3 âˆ’ 2â‹…(1/4+1/3) âˆ’ (1/4+1/4+1/4+1/3)            = +3/4 = /B.S./
        #+BEGIN_EXAMPLE
        âˆ§
         â‹… âŠ™
        Z X â—º
         â‹… âŠ™ âŠ™
        X Z X
         â‹… â‹… â‹…
        Z X Z âŸ©
        #+END_EXAMPLE

***** Convex corner obtuse Z-X :: 3 âˆ’ (1/2+1/4+1/3) âˆ’ (1/4+1/3) âˆ’ (1/4+1/4+1/4+1/3)  = +1/4
        #+BEGIN_EXAMPLE
          âˆ§
         â‹… âŠ™
        Z X â—º
         â‹… âŠ™ âŠ™
        X Z X
         â‹… â‹… â‹…
        Z X Z âŸ©
        #+END_EXAMPLE

***** Concave corner ğ›”-ğ›” near :: 1-(1/4+1/4+1/4)                                     = +1/4
        #+BEGIN_EXAMPLE
        â‹… â‹… â‹… â‹…
         X Z X âŸ©
        â‹… â‹… â‹… â‹…
         Z X Z
        â‹… â‹… â‹… â‹…
         X Z X âŸ©
        â‹… â‹… â‹… â‹…
         Z X Z   âˆ§   âˆ§
        â‹… â‹… â‹… âŠ™ â‹… â‹… â‹… â‹…
         X Z X Z X Z X
        â‹… â‹… â‹… â‹… â‹… â‹… â‹… â‹…
        #+END_EXAMPLE
        Figs. 8,9,21 in [fn:FoGi]

***** Concave corner ğ›”-ğ›” far+ramp :: 3 âˆ’ 2â‹…(1/4+1/4+1/3) âˆ’ (1/4+1/4+1/4+1/3)         = +1/4
        #+BEGIN_EXAMPLE
        â‹… â‹… â‹… â‹…
         Z X Z âŸ©
        â‹… â‹… â‹… â‹…
         X Z X
        â‹… â‹… â‹… âŠ™
         Z X Z â—º   âˆ§
        â‹… â‹… â‹… âŠ™ âŠ™ â‹… â‹… â‹…
         X Z X Z X Z X
        â‹… â‹… â‹… â‹… â‹… â‹… â‹… â‹…
        #+END_EXAMPLE
        Figs. 8,9,21 in [fn:FoGi]

***** â“â“â“ :: What is Fig. 9(b) in [fn:FoGi] ???

***** etc

**** Notes

      - Â»Concave corner ğ›”-ğ›” nearÂ« and Â»Concave corner ğ›”-ğ›” far+rampÂ« can be combined to give a 180Â° turn, as in
        Figs. 8,9 of [fn:FoGi].  The logQ contribution adds up to 1/2.


** TODO Memory
*** TODO Syndrome measurement

      * TODO :: Measurement circuits for single code block.  This is the question: How can you squeeze the
        measurement of all stabilizer generators into a quantum circuit that's as shallow as possible?

      * TODO :: Maybe?  Measurement circuits for two code blocks that are close together; see [[Â»Close ShaveÂ«]]
        implementation of [[Split]] below.

*** NEW Decoding

      * (Current) standard work is "Sparse Blossom"[fn:SparseBlossom]

*** TODO Fixing
*** TODO The thing with the repetitions...


** â†˜ï¸ Shape changes & moves; Merge & Split
*** â†˜ï¸ Expand & Shrink
***** MORE Expand

      Aka "grow"

      * Expand along ğ‚-boundary

        + Process:
          1. Prepare all new qubits in +ğ‚ state
          2. Measure all (new) stabilizers

        + Caveat: I have only checked it for expanding along into a rectangle, not around corners or whatnot (but
          it should work).

        + /Is this correct?!?/ â€” What you have to check:
          a) Check degrees of freedom: \\
             There needs to be 1 qubit degree of freedom left after step #2.  For example, here's a *wrong* process
             for expanding along the Z-boundary:
             1. Prepare all new qubits in *+X (wrong!)* state
             2. Measure all (new) stabilizers
             It's wrong because it leads to a logical X in the stabilizer group, i.e., there's 0 qubit degrees of
             freedom left.
             - Idea :: Maybe that's a cool way for log-qubit reset? ğŸ¤”
          b) Logical state before âŸ¿ after \\
             If a logical operator was in the stabilizer group before, the same one must still be present after.

        + TODO :: Pseudo code with log-frame updates

      * Expand along Z,X-boundaries at the same time
        + Fig. 11 in [fn:FoGi]


***** TODO Shrink
*** â†˜ï¸ Merge & Split
***** MORE Split

      * Definitions
        - X-split = |++âŸ©âŸ¨+| + |--âŸ©âŸ¨-|  = (|00âŸ©+|11âŸ©)âŸ¨0| + (|01âŸ©+|10âŸ©)âŸ¨1|  â«½âˆš2
          + ZX-diagram
            #+BEGIN_EXAMPLE
               â•±
             â”€X
               â•²
            #+END_EXAMPLE
        - Z-split = |00âŸ©âŸ¨0| + |11âŸ©âŸ¨1|
          + ZX-diagram
            #+BEGIN_EXAMPLE
               â•±
             â”€Z
               â•²
            #+END_EXAMPLE

      * Implementation 1: /Â»Close ShaveÂ«/  <<Â»Close ShaveÂ«>>
        + Measurement pattern
          1. Center part of logical qubit, boundaries left and right, not shown, are Z; logX is vertical X's:
            #+BEGIN_EXAMPLE
            âˆ§   âˆ§   âˆ§
             â‹… â‹… â‹… â‹… â‹…
            Z X ğ—­ X Z
             â‹… â‹… â‹… â‹… â‹…
            X Z ğ—« Z X
             â‹… â‹… â‹… â‹… â‹…
            Z X ğ—­ X Z
             â‹… â‹… â‹… â‹… â‹…
            X Z ğ—« Z X
             â‹… â‹… â‹… â‹… â‹…
              âˆ¨   âˆ¨
            #+END_EXAMPLE
          2. Measure ZâŠ—Z (vertical) on the left of each of the bold ğ—­s (the pairs on the right are implied).
          3. Result: ğ›• := tensor of all X's left and right of the removed stabilizer column; plus:
            #+BEGIN_EXAMPLE
            âˆ§        âˆ§
             â‹… â‹…  â‹… â‹… â‹…
            Z X âŸ©âŸ¨ X Z
             â‹… â‹…  â‹… â‹… â‹…
            X Z    Z X
             â‹… â‹…  â‹… â‹… â‹…
            Z X âŸ©âŸ¨ X Z
             â‹… â‹…  â‹… â‹… â‹…
            X Z    Z X
             â‹… â‹…  â‹… â‹… â‹…
              âˆ¨    âˆ¨
            #+END_EXAMPLE
            So we have 2 logical qubits, but their logical X's are equivalent through ğ›•

      * TODO :: Implementation 2: As in[fn:river]

      * Differences between Implementations 1 & 2:
        + In #2, two rows/columns of stabilizers â€” i.e., a whole row of data qubits â€” are measured out, while in
          #1, only one row/column of stabilizers is measured out, and no individual data qubits are measured.
        + TODO :: In #1, if you use measurement qubits, the same measurement qubit is used for two different code
          blocks (left and right) after the split.  This makes it more difficult (TODO: Impossible??) to squeeze
          the stabilizer measurements into an as-shallow-as-possible circuit.  This probably makes the
          Implementation 1 [[Â»Close ShaveÂ«]] simply silly.

***** TODO Merge

      * Definitions (with ZX-diagrams)
        + Merges have a classical outcome, ğ–º, so they reduce the quantum degrees of freedom from 2 to 1
        + Z-merge = |0âŸ©âŸ¨0ğ–º| + |1âŸ©âŸ¨1ğ–ºÌ…|
          #+BEGIN_EXAMPLE
          â”€â”€â”€â”
             Zâ”€
          â”€Xâ‚â”˜
          #+END_EXAMPLE
        + X-merge = |+âŸ©âŸ¨+ğ‘| + |-âŸ©âŸ¨-ğ‘Ì…|  where ğ‘ = (-1)áµƒ, and ğ‘Ì… = -(-1)áµƒ
          #+BEGIN_EXAMPLE
          â”€â”€â”€â”
             Xâ”€
          â”€Zâ‚â”˜
          #+END_EXAMPLE
       * TODO :: Implementation with stabilizer picture

*** â†˜ï¸ Miscellaneous
**** â†˜ï¸ Code rotations
***** MORE Silly rotate

      * Meaning: Z-boundary and X-boundary are exchanged.
        + ... but what happens with logical Z,X â€” are they kept?

      * Htrans + Hvirt :: Possibly in parallel:
        + Apply H to each data qubit (transversal [[H-gate]])
        + Swap Z,X logical ops (virtual [[H-gate]])

***** MORE FoGi rotate

      * This is Fig. 13 in [fn:FoGi] and Fig. 10(b-c) in [fn:river]
      * There are loads of choices, e.g.,:
        - [fn:FoGi] puts the [[Convex corner obtuse ğ›”-ğ›” near][obtuse corner]] at the end of the edge which contains the [[Skip 1 on an edge][skip-1]], while
        - [fn:river] put the [[Convex corner obtuse ğ›”-ğ›” near][obtuse corner]] at the end of the edge opposite of the edge with the [[Skip 1 on an edge][skip-1]].
        - The protocol is different depending on even/odd-ness of rows/columns: the -1/4 (on a corner) that's
          necessary to cancel the +1/2 from the [[Skip 1 on an edge][skip-1]] can be a Â»[[Convex corner obtuse ğ›”-ğ›” near]]Â« (odd[fn:FoGi]) or a
          Â»[[Convex corner ğ›”-ğ›” near]]Â« (even[fn:river]).
        - [fn:river] expand and shrink simultaneously with the rotating while [fn:FoGi] leaves the rectangle as it
          is (except for obtusing corners).

      * TODO :: ğŸ¤”ğŸ¤” On the one hand, pseudocode for this will be a PITA because there are so many cases.  On the
        other hand, the complexity of this operation (with cases etc) might make it a good test case to validate
        "Pauli Assembler".

*** TODO Etc
***** etc


** â†˜ï¸ Operations
*** â†˜ï¸ State preparation
***** MORE Â±Z, Â±X

      * +ğ›” where ğ›” âˆˆ {Z,X}:
        #+BEGIN_SRC python
          for q in dataqubits:
              q.init(+ğ›”)
          EC(d times)
        #+END_SRC
        Cost:
        + 1 QEC cycle
          - ... that can be merged with next op[fn:river]
          - TODO :: how exactly?

      * TODO :: There's sure to be a shortcut for preparing -Z and -X

***** TODO Â±Y

*** MORE Single qubit Clifford gates
***** REVIEW Pauli-{X,Z} gates

      * Transversal :: (Only if length of observable is odd)[fn:river]
        + Space-time cost: Time = 1 cycle
        + Error cost:
          - *Z*: with /virtual/ Z-gate: 0
          - *X*, *Z* w/o virtual Z-gate: loads of 1-qubit gates

      * Virtual P   :: Flip /frame/ of every physical qubit & *propagate*
        - ??? This doesn't look like it makes any sense...

      * Virtual L   :: Flip sign of logical op[fn:river]

***** Pauli-Y gate

      * Transversal :: (Only if lengths of Z,X observables are both odd)[fn:river]

      * Apply â›Zâ›Xâ› or â›Xâ›Zâ›; e.g., ~X{virt}, Ztrans~
        - difference is global phase
        - can be done in parallel

***** MORE H-gate

      * Transversal :: (TODO explain)

      * Virtual :: Swap Z,X logical ops
        + I.e., say,
          - before: ZÌ… between Z-boundaries, XÌ…  between X-boundaries;
          - after:  ZÌ… between X-boundaries, XÌ…  between Z-boundaries.
        + Cf. [[Code rotations]]

      * With rotation :: TODO

***** S-gate

      * Magic state :: <<Â¤S-magic>>
        + Prepare ğ—¦|+âŸ© state on aux, measure ZâŠ—Z, measure Xâ‚áµ¤â‚“, fix[fn:river]
          - ZX-diagram:
            #+BEGIN_EXAMPLE
             +----------------+
             |                |
             | Zâ”€ZÂ½â”€â”€Zâ”€â”€Zâ‚œ    |
             |       â”‚        |
             |       Xâ‚       |
             |       â”‚        |
            â”€â”€â”€â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€Zâ‚œâ‚Šâ‚â”€â”€â”€
             |                |
             +----------------+
            #+END_EXAMPLE
        + Simpler: ğ—¦|+âŸ© state on aux, merge, fix:
          - ZX-diagram (also fused ~Zâ”€ZÂ½â”€~ to ~ZÂ½â”€~):
            #+BEGIN_EXAMPLE
             +------------+
             |            |
             | ZÂ½         |
             |   â•²        |
             |    Xâ‚      |
             |     â•²      |
            â”€â”€â”€â”€â”€â”€â”€â”€Zâ”€â”€Zâ‚â”€â”€â”€
             |            |
             +------------+
            #+END_EXAMPLE

*** â†˜ï¸ Single-qubit measurement
***** ARGH Z,X

      * Destructive :: Measure all data qubits.[fn:river]
        + TODO :: Question: How to handle error detecting info that arises?
        + TODO :: Write pseudocode

      * Slicing off ::  (Trivial) ğ‚-[[Split]] then ğ‚-basis measurement
        + Split off 1 column/row of weight-4 stabilizers (to measure ğ›”, do ğ›” split)
          - In other words, [[Split]] qubit in two and perform destructive measurement of one of the 2 parts.
        + ZX-diagram (for measuring Z):
          #+BEGIN_EXAMPLE
           +-------+
           |       |
          â”€â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€
           |  â”‚    |
           |  â””â”€Xâ‚ |
           +-------+
          #+END_EXAMPLE
          - The ~â”€Xâ‚~ measurement (i.e., â¦¨Z) in the diagram can be performed on a trivial "logical qubit"
            consisting of only one row or column of data qubits, e.g.:
            #+BEGIN_EXAMPLE
               âˆ§
            â‹… â‹… â‹…        â‹… â‹…  â‹…
             Z ğ—«          Z âŸ©âŸ¨
            â‹… â‹… â‹…        â‹… â‹…  â‹…
             X ğ—­ âŸ©        X    âŸ©
            â‹… â‹… â‹…    â‡’   â‹… â‹…  â‹…
             Z ğ—«          Z âŸ©âŸ¨
            â‹… â‹… â‹…        â‹… â‹…  â‹…
             X ğ—­ âŸ©        X    âŸ©
            â‹… â‹… â‹…        â‹… â‹…  â‹…
             âˆ¨            âˆ¨
            #+END_EXAMPLE
          - Remember that on the RHS there's an additional stabilizer from the split that's not part of any of the
            two logical qubits: the tensor product of the Z's of all the data qubits (10, in our case) on the
            deleted stabilizer column; the value of it is known (as it's the product of all bold plus one ~âˆ§~
            Z-stabilizers in the logical qubit before the split, and it means that the Z-value on the left
            remaining logQ is up-to-sign the same as the Z-value of the right remaining (trivial) logQ.
        + â¾ each data qubit in single remaining column/row holds observable value up to sign
        + Careful: distance may decrease ([[Expand]] before?)
        + TODO :: Question: How to handle error detecting info that arises?  (The product of every 2 consecutive
          data qubits in the row/column is a stabilizer known.)

      * Slicing on :: ğ‚-stateprep + (trivial) ğ‚-[[Merge]]
        + ZX-diagram (for measuring Z):
          #+BEGIN_EXAMPLE
           +----------+
           |          |
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€
           | Xâ‚€â”€â”€â”€Xâ‚â”˜ |
           +----------+
          #+END_EXAMPLE
        + The |0âŸ© state preparation (~Xâ‚€â”€~ in ZX-diagram) can be a performed on a trivial logical qubit
          consisting of a single row/column.
          - ... or any size, really.
        + Interestingly, there's no destructive measurement anywhere in this approach.

*** 2-qubit Clifford gates
***** MORE CNOT

      * Z-split + X-merge + fix[fn:HFDM11] <<Z-split+X-merge>>
        + 'Fix' refers to fixing the effect of the measurement outcome "ğ–º": a Z-gate has to be applied if that ğ–º=1.
        + ZX-diagram:
          #+BEGIN_EXAMPLE
           +--------+
           |        |
          â”€â”€â”€â”€Zâ”€â”€Zâ‚â”€â”€â”€
           |  â”‚     |
           |  â”‚     |
           |  Zâ‚    |
           |  â”‚     |
          â”€â”€â”€â”€Xâ”€â”€â”€â”€â”€â”€â”€
           |        |
           +--------+
          #+END_EXAMPLE
        + The vertical line in the ZX-diagram can be thought of as an auxiliary logical qubit.
        + Applying the Z-gate can be done virtually, of course.
        + TODO :: Split & merge can be done in parallel â€” TODO: *Work out how!*[fn:GiCNOT]
        + TODO :: Work out cost & compare with [[â¦¨ZZ+â¦¨XX]]
        + TODO :: Write pseudocode!

      * â¦¨ZZ + â¦¨XX + fix <<â¦¨ZZ+â¦¨XX>>
        + This is used in[fn:river]
        + ZX-diagram:
          #+BEGIN_EXAMPLE
           +--------------------+
           |                    |
          â”€â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€â”€â”€â”€Zâ‚‘â”€â”€â”€â”€â”€
           |     â”‚              |
           |     Xâ‚             |
           |     â”‚              |
           | Zâ‚€â”€â”€Zâ”€â”€â”€Xâ”€â”€Xâ‚•      |
           |         â”‚          |
           |         Zâ‚‘         |
           |         â”‚          |
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Xâ”€â”€â”€â”€â”€Xâ‚â‚Šâ‚•â”€â”€â”€
           |                    |
           +--------------------+
          #+END_EXAMPLE
        + Don't forget: ~Zâ‚€â”€~ is |+âŸ© state prep (i.e., X-basis), and ~â”€Xâ‚•~ is Z-basis measurement.
        + Why is this correct? Use standard ZX-calculus!
        + TODO :: Work out cost & compare with [[Z-split+X-merge]]
        + TODO :: Write pseudocode!
        + TODO :: ğŸ¤”ğŸ¤”ğŸ¤” On the level of elementary operations (Pasm) is this really different from
          [[Z-split+X-merge]]?

*** â†˜ï¸ Multi-qubit Pauli measurement
***** MORE Measure ZZ,XX

      * Z-split /then/ Z-merge
        + ZX-diagram for â¦¨ZZ
          #+BEGIN_EXAMPLE
           +--------+
           |        |
          â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€â”€â”€
           |  â•²     |
           |   â•²    |
           |    Xâ‚  |
           |     â•²  |
          â”€â”€â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€
           |        |
           +--------+
          #+END_EXAMPLE
        + I think this is the same as in[fn:FoGi]
        + TODO :: Write pseudocode!

      * Z-merge /then/ Z-split, plus fix
        + ZX-diagram for â¦¨ZZ
          #+BEGIN_EXAMPLE
           +------------+
           |            |
          â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€
           |    â”‚  â”‚    |
           |    Zâ”€â”€Z    |
           |    â”‚  â”‚    |
          â”€â”€â”€Xâ‚â”€â”˜  â””â”€Xâ‚â”€â”€â”€
           |            |
           +------------+
          #+END_EXAMPLE
        + Why is this correct?  Transform ZX-diagram above ("1.") as follows:
          2. [@2]
             #+BEGIN_EXAMPLE
              +------------+
              |            |
             â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€â”€â”€â”€
              |    â”‚       |
              |    â”‚       |
              |    â”‚       |
             â”€â”€â”€Xâ‚â”€Zâ”€â”€â”€â”€Xâ‚â”€â”€â”€
              |            |
              +------------+
             #+END_EXAMPLE
          3.
             #+BEGIN_EXAMPLE
              +------------+
              |            |
             â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€â”€â”€â”€
              |    â”‚       |
              |    Xâ‚      |
              |    â”‚       |
             â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€â”€â”€â”€
              |            |
              +------------+
             #+END_EXAMPLE
        + TODO :: Write pseudocode!

*** MORE Non-Clifford stuff
**** MORE T-gate
***** Gate teleportation when magic state |0âŸ©+âˆšğ’Š|1âŸ© is available

      * Gate teleportation when magic state |0âŸ©+âˆšğ’Š|1âŸ© is available
        + Similar to [[Â¤S-magic]]
        + ZX-diagram (also fused ~Zâ”€ZÂ½â”€~ to ~ZÂ½â”€~):
          #+BEGIN_EXAMPLE
           +---------------+
           |               |
           | ZÂ¼            |
           |   â•²           |
           |    Xâ‚         |
           |     â•²         |
          â”€â”€â”€â”€â”€â”€â”€â”€Zâ”€â”€Zâ‚â¸â‚‚â”€â”€â”€â”€
           |               |
           +---------------+
          #+END_EXAMPLE

      * River[fn:river:] have their own complicated way of doing the same thing, cf. [[Â¤S-magic][S-Gate with magic states]].

***** Magic state factories



* Footnotes = Bibliography
** Necessary reading: Now

  1) Microsoft[fn:microsoft: ~arXiv:2211.07629~ /Assessing requirements to scale to practical quantum advantage/] *Source code = Where?!?*

  2) Riverlane[fn:river: ~arXiv:2307.03233~ /Compilation of a simple chemistry application/ (Riverlane)] *Source code = Where?!?*

  3) Lattice Surgery Compiler[fn:LaSuCom: ~arXiv:2302.02459~ /A High Performance Compiler for Very Large Scale Surface Code Computations./]  [[https://latticesurgery.com][latticesurgery.com]]  *Has a test suite!*

  4) Oak Ridge[fn:oak: ~arXiv:2311.10687~ /TISCC: A Surface Code Compiler and Resource Estimator for Trapped-Ion Processors/] *Includes verification!* [[https://github.com/ORNL-QCI/TISCC][github.com/ORNL-QCI/TISCC]]

** Necessary reading: Later

  5) [@5] Fowler-Gidney[fn:FoGi: ~arXiv:1808.06709~ /Low overhead quantum computation using lattice surgery/ Fowler & Gidney]

  6) Litinski /Game of Surface Codes/

  7) Other Litinski stuff, e.g., on magic states.

  Further:

  * Beverland-Kliuchnikov-Schoute: /Surface code compilation via edge-disjoint paths/.  arXiv:2110.11493

  * Kliuchnikov-Beverland-Paetznick: /Stabilizer circuit verification/.  arXiv:2309.08676

  * Beverland-...-Kliuchnikov: /Fault tolerance of stabilizer channels/.  arXiv:2401.12017

** Other references

  * HFDM11[fn:HFDM11: ~arXiv:1111.4022~ /Surface code quantum computing by lattice surgery./ Horsman, Fowler,
    Devitt, Meter] Keep in mind that this paper is about the un-rotated surface code.

  * Sparse Blossom[fn:SparseBlossom: ~arXiv:2303:15933~ /Sparse Blossom: Correcting a million errors per
        core second with minimum-weight matching./ Higgot & Gidney] [[https://github.com/oscarhiggott/PyMatching][github.com/oscarhiggott/PyMatching]]

** Online discussions

  * Gidney-QCSX-CNOT [fn:GiCNOT: Gidney's answer on Quantum-Computing Stackexchange,
    [[https://quantumcomputing.stackexchange.com/questions/20830/how-can-surface-codes-perform-splitting-and-merging-at-the-same-time-when-they-i]]]

  * [[https://quantumcomputing.stackexchange.com/questions/32048/rigorous-understanding-that-one-should-correct-pauli-drift-before-non-clifford][Gidney on propagating physical Pauli fixups through non-Clifford gates]]

  * [[https://quantumcomputing.stackexchange.com/questions/38232/deformation-rules-for-zx-pipe-diagrams][Gidney's reply to /Deformation rules for ZX-pipe diagrams/.]]  DOT: Has recommended reading! ğŸ˜Š

** EOF
# Local Variables:
# fill-column: 115
# End:
