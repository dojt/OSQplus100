#+TITLE:  Encyclopedia of Stabilizer Code Operations
#+DATE:   Thu May 23 18:10:10 EEST 2024
#+SETUPFILE: ./org-mode-header.org
:SET_STUFF_UP:
#+INCLUDE: "~/Git/DOT_LaTeX/org-latex-export-defs.org"
#+STARTUP: overview
#+SEQ_TODO: TODO MORE â†˜ï¸ ARGH | REVIEW NEW
#+BEGIN_HTML
\(
\newcommand{\sodifjosidjfosidjfosijdfosijdfoisjdfoijsdofijsodifjosidjfosidj}{\mathscr{A}}
\newcommand{\viusbidufhwiefsdofijsoifjaoidsjfoiqhwoeufhaosudfhoauisdhfoaiwe}[1]{A #1}
\)
#+END_HTML
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+BEGIN_COMMENT
â—ï¸ *WARNING!  GPLv3*
#+END_COMMENT
#+PROPERTY: header-args :eval never :exports code :noweb no-export :noweb-prefix no
:END:

* Lattice Surgery
** â†˜ï¸ Code
***** MORE Shapes

      * Textbook shape ğ‘‘=7: 7Ã—7 physical qubits
        #+BEGIN_EXAMPLE
         âˆ§ âˆ§ âˆ§
         XZXZXZâŸ©
        âŸ¨ZXZXZX
         XZXZXZâŸ©
        âŸ¨ZXZXZX
         XZXZXZâŸ©
        âŸ¨ZXZXZX
          âˆ¨ âˆ¨ âˆ¨
        #+END_EXAMPLE

      * Textbook expansion (growing) leads to ğ‘‘Ã—ğ‘’ blocks, with both ğ‘‘,ğ‘’ odd and â‰¥3

      * The condition ğ‘‘,ğ‘’ odd can be dropped.  Then errors of weight ğ‘‘/2 or ğ‘’/2 can only be detected, not
        corrected.

      * Exotic rectangular :: See [fn:FoGi] 13.

      * Non-rectangular :: See [fn:FoGi], figures 7,8,9,21.
        + Note: Fig. 7(b) has 1 logical qubit; Fig. 8(b) has 2 logical qubits.

      * What?!?? :: What is Fig. 9(b) in [fn:FoGi] ???

***** MORE "Logical contributions" of physical qubit neighborhoods

      * In the bulk :: 1-(1/4+1/4+1/4+1/4)                                             = 0
        #+BEGIN_EXAMPLE
        Z X
         âŠ™
        X Z
        #+END_EXAMPLE

      * On an edge :: 1-(1/4+1/4+1/2)                                                  = 0
        #+BEGIN_EXAMPLE
        X
         âŠ™
        Z âŸ©
        #+END_EXAMPLE

      * Skip 1 on an edge :: 1-(1/4+1/4)                                               = 1/2
        #+BEGIN_EXAMPLE
          âˆ§     âˆ§
         â‹… â‹… âŠ™ â‹… â‹…
        Z X Z X Z X
        #+END_EXAMPLE
        See Figs. 7,13 in [fn:FoGi]

      * Convex corner std Z-X :: 1-(1/4+1/2)                                           = 1/4
        #+BEGIN_EXAMPLE
        âˆ§   âˆ§
         â‹… â‹… âŠ™
        Z X Z
         â‹… â‹… â‹…
        X Z X âŸ©
        #+END_EXAMPLE

      * Convex corner near ğ›”-ğ›” :: 1-(1/4+1/2+1/2)                                      = -1/4
        #+BEGIN_EXAMPLE
        âˆ§   âˆ§
         â‹… â‹… âŠ™
        Z X Z âŸ©
         â‹… â‹… â‹…
        X Z X
         â‹… â‹… â‹…
        Z X Z âŸ©
        #+END_EXAMPLE
        See Fig. 21 in [fn:FoGi]

      * Convex corner obtuse ğ›”-ğ›” near :: 3 âˆ’ 2â‹…(1/2+1/4+1/3) âˆ’ (1/4+1/4+1/4+1/3)       = -1/4
        #+BEGIN_EXAMPLE
          âˆ§
         â‹… âŠ™
        Z X â—º
         â‹… âŠ™ âŠ™
        X Z X âŸ©
         â‹… â‹… â‹…
        Z X Z
        #+END_EXAMPLE
        See Figs. 7,8,9,13 in [fn:FoGi]

      * Convex corner obtuse ğ›”-ğ›” far :: 3 âˆ’ 2â‹…(1/4+1/3) âˆ’ (1/4+1/4+1/4+1/3)            = 3/4 = /SHIT/
        #+BEGIN_EXAMPLE
        âˆ§
         â‹… âŠ™
        Z X â—º
         â‹… âŠ™ âŠ™
        X Z X
         â‹… â‹… â‹…
        Z X Z âŸ©
        #+END_EXAMPLE

      * Convex corner obtuse Z-X :: 3 âˆ’ (1/2+1/4+1/3) âˆ’ (1/4+1/3) âˆ’ (1/4+1/4+1/4+1/3)  = 1/4
        #+BEGIN_EXAMPLE
          âˆ§
         â‹… âŠ™
        Z X â—º
         â‹… âŠ™ âŠ™
        X Z X
         â‹… â‹… â‹…
        Z X Z âŸ©
        #+END_EXAMPLE

      * Concave corner ğ›”-ğ›” near :: 1-(1/4+1/4+1/4)                                     = 1/4
        #+BEGIN_EXAMPLE
        â‹… â‹… â‹… â‹…
         X Z X âŸ©
        â‹… â‹… â‹… â‹…
         Z X Z
        â‹… â‹… â‹… â‹…
         X Z X âŸ©
        â‹… â‹… â‹… â‹…
         Z X Z   âˆ§   âˆ§
        â‹… â‹… â‹… âŠ™ â‹… â‹… â‹… â‹…
         X Z X Z X Z X
        â‹… â‹… â‹… â‹… â‹… â‹… â‹… â‹…
        #+END_EXAMPLE
        Figs. 8,9,21 in [fn:FoGi]

      * Concave corner ğ›”-ğ›” far+ramp :: 3 âˆ’ 2â‹…(1/4+1/4+1/3) âˆ’ (1/4+1/4+1/4+1/3)         = 1/4
        #+BEGIN_EXAMPLE
        â‹… â‹… â‹… â‹…
         Z X Z âŸ©
        â‹… â‹… â‹… â‹…
         X Z X
        â‹… â‹… â‹… âŠ™
         Z X Z â—º   âˆ§
        â‹… â‹… â‹… âŠ™ âŠ™ â‹… â‹… â‹…
         X Z X Z X Z X
        â‹… â‹… â‹… â‹… â‹… â‹… â‹… â‹…
        #+END_EXAMPLE
        Figs. 8,9,21 in [fn:FoGi]

      * â“â“â“ :: What is Fig. 9(b) in [fn:FoGi] ???

      * etc

      _Notes_

      - Â»Concave corner ğ›”-ğ›” nearÂ« and Â»Concave corner ğ›”-ğ›” far+rampÂ« can be combined to give a 180Â° turn, as in
        Figs. 8,9 of [fn:FoGi].  The logQ contribution adds up to 1/2.


** TODO Memory
*** TODO Syndrome measurement

      * TODO :: Measurement circuits for single code block.  This is the question: How can you squeeze the
        measurement of all stabilizer generators into a quantum circuit that's as shallow as possible?

      * TODO :: Maybe?  Measurement circuits for two code blocks that are close together; see [[Â»Close ShaveÂ«]]
        implementation of [[Split]] below.

*** Decoding

      * (Current) standard work is "Sparse Blossom"[fn:SparseBlossom]

*** Fixing


** â†˜ï¸ Shape changes & moves
***** MORE Expand / Grow and Shrink

      * Expand along ğ‚-boundary

        + Process:
          1. Prepare all new qubits in +ğ‚ state
          2. Measure all (new) stabilizers

        + Caveat: I have only checked it for expanding along into a rectangle, not around corners or whatnot (but
          it should work).

        + What you have to check is that there's 1 qubit degree of freedom left after step #2


        + *Wrong* process for expand along Z boundary:
          1. Prepare all new qubits in *+X (wrong!)* state
          2. Measure all (new) stabilizers
          It's wrong because it leads to a logical X in the stabilizer group, i.e., there's 0 qubit degrees of
          freedom left.
          - Idea :: Maybe that's a cool way for log-qubit reset? ğŸ¤”

        + TODO :: Pseudo code with log-frame updates

      * Shrink

***** MORE Split

      * Definitions
        - X-split = |++âŸ©âŸ¨+| + |--âŸ©âŸ¨-|  = (|00âŸ©+|11âŸ©)âŸ¨0| + (|01âŸ©+|10âŸ©)âŸ¨1|  â«½âˆš2
          + ZX-diagram
            #+BEGIN_EXAMPLE
               â•±
             â”€X
               â•²
            #+END_EXAMPLE
        - Z-split = |00âŸ©âŸ¨0| + |11âŸ©âŸ¨1|
          + ZX-diagram
            #+BEGIN_EXAMPLE
               â•±
             â”€Z
               â•²
            #+END_EXAMPLE

      * Implementation 1: /Â»Close ShaveÂ«/  <<Â»Close ShaveÂ«>>
        + Measurement pattern
          1. Center part of logical qubit, boundaries left and right, not shown, are Z; logX is vertical X's:
            #+BEGIN_EXAMPLE
            âˆ§   âˆ§   âˆ§
             â‹… â‹… â‹… â‹… â‹…
            Z X ğ—­ X Z
             â‹… â‹… â‹… â‹… â‹…
            X Z ğ—« Z X
             â‹… â‹… â‹… â‹… â‹…
            Z X ğ—­ X Z
             â‹… â‹… â‹… â‹… â‹…
            X Z ğ—« Z X
             â‹… â‹… â‹… â‹… â‹…
              âˆ¨   âˆ¨
            #+END_EXAMPLE
          2. Measure ZâŠ—Z (vertical) on the left of each of the bold ğ—­s (the pairs on the right are implied).
          3. Result: ğ›• := tensor of all X's left and right of the removed stabilizer column; plus:
            #+BEGIN_EXAMPLE
            âˆ§        âˆ§
             â‹… â‹…  â‹… â‹… â‹…
            Z X âŸ©âŸ¨ X Z
             â‹… â‹…  â‹… â‹… â‹…
            X Z    Z X
             â‹… â‹…  â‹… â‹… â‹…
            Z X âŸ©âŸ¨ X Z
             â‹… â‹…  â‹… â‹… â‹…
            X Z    Z X
             â‹… â‹…  â‹… â‹… â‹…
              âˆ¨    âˆ¨
            #+END_EXAMPLE
            So we have 2 logical qubits, but their logical X's are equivalent through ğ›•

      * TODO :: Implementation 2: As in[fn:river]

      * Differences between Implementations 1 & 2:
        + In #2, two rows/columns of stabilizers â€” i.e., a whole row of data qubits â€” are measured out, while in
          #1, only one row/column of stabilizers is measured out, and no individual data qubits are measured.
        + TODO :: In #1, if you use measurement qubits, the same measurement qubit is used for two different code
          blocks (left and right) after the split.  This makes it more difficult (TODO: Impossible??) to squeeze
          the stabilizer measurements into an as-shallow-as-possible circuit.  This probably makes the
          Implementation 1 [[Â»Close ShaveÂ«]] simply silly.

***** TODO Merge

      * Definitions (with ZX-diagrams)
        + Merges have a classical outcome, ğ–º, so they reduce the quantum degrees of freedom from 2 to 1
        + Z-merge = |0âŸ©âŸ¨0ğ–º| + |1âŸ©âŸ¨1ğ–ºÌ…|
          #+BEGIN_EXAMPLE
          â”€â”€â”€â”
             Zâ”€
          â”€Xâ‚â”˜
          #+END_EXAMPLE
        + X-merge = |+âŸ©âŸ¨+ğ‘| + |-âŸ©âŸ¨-ğ‘Ì…|  where ğ‘ = (-1)áµƒ, and ğ‘Ì… = -(-1)áµƒ
          #+BEGIN_EXAMPLE
          â”€â”€â”€â”
             Xâ”€
          â”€Zâ‚â”˜
          #+END_EXAMPLE
       * TODO :: Implementation with stabilizer picture

***** REVIEW Full rotate

      * Meaning: Z-boundary and X-boundary are exchanged.
        + ... but what happens with logical Z,X â€” are they kept?

      * Htrans + Hvirt :: Possibly in parallel:
        + Apply H to each data qubit (transversal [[H-gate]])
        + Swap Z,X logical ops (virtual [[H-gate]])

***** TODO FoGi rotate

      From [fn:FoGi]

***** TODO etc


** â†˜ï¸ Operations
*** â†˜ï¸ State preparation
***** MORE Â±Z, Â±X

      * +ğ›” where ğ›” âˆˆ {Z,X}:
        #+BEGIN_SRC python
          for q in dataqubits:
              q.init(+ğ›”)
          EC(d times)
        #+END_SRC
        Cost:
        + 1 QEC cycle
          - ... that can be merged with next op[fn:river]
          - TODO :: how exactly?

      * TODO :: There's sure to be a shortcut for preparing -Z and -X

***** TODO Â±Y

*** MORE Single qubit Clifford gates
***** REVIEW Pauli-{X,Z} gates

      * Transversal :: (Only if length of observable is odd)[fn:river]
        + Space-time cost: Time = 1 cycle
        + Error cost:
          - *Z*: with /virtual/ Z-gate: 0
          - *X*, *Z* w/o virtual Z-gate: loads of 1-qubit gates

      * Virtual P   :: Flip /frame/ of every physical qubit & *propagate*
        - ??? This doesn't look like it makes any sense...

      * Virtual L   :: Flip sign of logical op[fn:river]

***** Pauli-Y gate

      * Transversal :: (Only if lengths of Z,X observables are both odd)[fn:river]

      * Apply â›Zâ›Xâ› or â›Xâ›Zâ›; e.g., ~X{virt}, Ztrans~
        - difference is global phase
        - can be done in parallel

***** REVIEW H-gate

      * Transversal :: (TODO explain)

      * Virtual :: Swap Z,X logical ops
        + I.e., say,
          - before: ZÌ… between Z-boundaries, XÌ…  between X-boundaries;
          - after:  ZÌ… between X-boundaries, XÌ…  between Z-boundaries.
        + Cf. [[Full rotate]]

*** â†˜ï¸ Single-qubit measurement
***** ARGH Z,X

      * Destructive :: Measure all data qubits.[fn:river]
        + TODO :: Question: How to handle error detecting info that arises?
        + TODO :: Write pseudocode

      * Slicing off ::  (Trivial) ğ‚-[[Split]] then ğ‚-basis measurement
        + Split off 1 column/row of weight-4 stabilizers (to measure ğ›”, do ğ›” split)
          - In other words, [[Split]] qubit in two and perform destructive measurement of one of the 2 parts.
        + ZX-diagram (for measuring Z):
          #+BEGIN_EXAMPLE
           +-------+
           |       |
          â”€â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€
           |  â”‚    |
           |  â””â”€Xâ‚ |
           +-------+
          #+END_EXAMPLE
          - The ~â”€Xâ‚~ measurement (i.e., â¦¨Z) in the diagram can be performed on a trivial "logical qubit"
            consisting of only one row or column of data qubits, e.g.:
            #+BEGIN_EXAMPLE
               âˆ§
            â‹… â‹… â‹…        â‹… â‹…  â‹…
             Z ğ—«          Z âŸ©âŸ¨
            â‹… â‹… â‹…        â‹… â‹…  â‹…
             X ğ—­ âŸ©        X    âŸ©
            â‹… â‹… â‹…    â‡’   â‹… â‹…  â‹…
             Z ğ—«          Z âŸ©âŸ¨
            â‹… â‹… â‹…        â‹… â‹…  â‹…
             X ğ—­ âŸ©        X    âŸ©
            â‹… â‹… â‹…        â‹… â‹…  â‹…
             âˆ¨            âˆ¨
            #+END_EXAMPLE
          - Remember that on the RHS there's an additional stabilizer from the split that's not part of any of the
            two logical qubits: the tensor product of the Z's of all the data qubits (10, in our case) on the
            deleted stabilizer column; the value of it is known (as it's the product of all bold plus one ~âˆ§~
            Z-stabilizers in the logical qubit before the split, and it means that the Z-value on the left
            remaining logQ is up-to-sign the same as the Z-value of the right remaining (trivial) logQ.
        + â¾ each data qubit in single remaining column/row holds observable value up to sign
        + Careful: distance may decrease ([[Expand]] before?)
        + TODO :: Question: How to handle error detecting info that arises?  (The product of every 2 consecutive
          data qubits in the row/column is a stabilizer known.)

      * Slicing on :: ğ‚-stateprep + (trivial) ğ‚-[[Merge]]
        + ZX-diagram (for measuring Z):
          #+BEGIN_EXAMPLE
           +----------+
           |          |
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€
           | Xâ‚€â”€â”€â”€Xâ‚â”˜ |
           +----------+
          #+END_EXAMPLE
        + The |0âŸ© state preparation (~Xâ‚€â”€~ in ZX-diagram) can be a performed on a trivial logical qubit
          consisting of a single row/column.
          - ... or any size, really.
        + Interestingly, there's no destructive measurement anywhere in this approach.

*** 2-qubit Clifford gates
***** MORE CNOT

      * Z-split + X-merge + fix[fn:HFDM11] <<Z-split+X-merge>>
        + 'Fix' refers to fixing the effect of the measurement outcome "ğ–º": a Z-gate has to be applied if that ğ–º=1.
        + ZX-diagram:
          #+BEGIN_EXAMPLE
           +--------+
           |        |
          â”€â”€â”€â”€Zâ”€â”€Zâ‚â”€â”€â”€
           |  â”‚     |
           |  â”‚     |
           |  Zâ‚    |
           |  â”‚     |
          â”€â”€â”€â”€Xâ”€â”€â”€â”€â”€â”€â”€
           |        |
           +--------+
          #+END_EXAMPLE
        + The vertical line in the ZX-diagram can be thought of as an auxiliary logical qubit.
        + Applying the Z-gate can be done virtually, of course.
        + TODO :: Split & merge can be done in parallel â€” TODO: *Work out how!*[fn:GiCNOT]
        + TODO :: Work out cost & compare with [[â¦¨ZZ+â¦¨XX]]
        + TODO :: Write pseudocode!

      * â¦¨ZZ + â¦¨XX + fix <<â¦¨ZZ+â¦¨XX>>
        + This is used in[fn:river]
        + ZX-diagram:
          #+BEGIN_EXAMPLE
           +--------------------+
           |                    |
          â”€â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€â”€â”€â”€Zâ‚‘â”€â”€â”€â”€â”€
           |     â”‚              |
           |     Xâ‚             |
           |     â”‚              |
           | Zâ‚€â”€â”€Zâ”€â”€â”€Xâ”€â”€Xâ‚•      |
           |         â”‚          |
           |         Zâ‚‘         |
           |         â”‚          |
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€Xâ”€â”€â”€â”€â”€Xâ‚â‚Šâ‚•â”€â”€â”€
           |                    |
           +--------------------+
          #+END_EXAMPLE
        + Don't forget: ~Zâ‚€â”€~ is |+âŸ© state prep (i.e., X-basis), and ~â”€Xâ‚•~ is Z-basis measurement.
        + Why is this correct? Use standard ZX-calculus!
        + TODO :: Work out cost & compare with [[Z-split+X-merge]]
        + TODO :: Write pseudocode!
        + TODO :: ğŸ¤”ğŸ¤”ğŸ¤” On the level of elementary operations (Pasm) is this really different from
          [[Z-split+X-merge]]?

*** â†˜ï¸ Multi-qubit Pauli measurement
***** MORE Measure ZZ,XX

      * Z-split /then/ Z-merge
        + ZX-diagram for â¦¨ZZ
          #+BEGIN_EXAMPLE
           +--------+
           |        |
          â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€â”€â”€
           |  â•²     |
           |   â•²    |
           |    Xâ‚  |
           |     â•²  |
          â”€â”€â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€
           |        |
           +--------+
          #+END_EXAMPLE
        + I think this is the same as in[fn:FoGi]
        + TODO :: Write pseudocode!

      * Z-merge /then/ Z-split, plus fix
        + ZX-diagram for â¦¨ZZ
          #+BEGIN_EXAMPLE
           +------------+
           |            |
          â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€
           |    â”‚  â”‚    |
           |    Zâ”€â”€Z    |
           |    â”‚  â”‚    |
          â”€â”€â”€Xâ‚â”€â”˜  â””â”€Xâ‚â”€â”€â”€
           |            |
           +------------+
          #+END_EXAMPLE
        + Why is this correct?  Transform ZX-diagram above ("1.") as follows:
          2. [@2]
             #+BEGIN_EXAMPLE
              +------------+
              |            |
             â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€â”€â”€â”€
              |    â”‚       |
              |    â”‚       |
              |    â”‚       |
             â”€â”€â”€Xâ‚â”€Zâ”€â”€â”€â”€Xâ‚â”€â”€â”€
              |            |
              +------------+
             #+END_EXAMPLE
          3.
             #+BEGIN_EXAMPLE
              +------------+
              |            |
             â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€â”€â”€â”€
              |    â”‚       |
              |    Xâ‚      |
              |    â”‚       |
             â”€â”€â”€â”€â”€â”€Zâ”€â”€â”€â”€â”€â”€â”€â”€â”€
              |            |
              +------------+
             #+END_EXAMPLE
        + TODO :: Write pseudocode!



* Footnotes = Bibliography
** Necessary reading: Now

  1) Microsoft[fn:microsoft: ~arXiv:2211.07629~ /Assessing requirements to scale to practical quantum advantage/] *Source code = Where?!?*

  2) Riverlane[fn:river: ~arXiv:2307.03233~ /Compilation of a simple chemistry application/ (Riverlane)] *Source code = Where?!?*

  3) Lattice Surgery Compiler[fn:LaSuCom: ~arXiv:2302.02459~ /A High Performance Compiler for Very Large Scale Surface Code Computations./]  [[https://latticesurgery.com][latticesurgery.com]]  *Has a test suite!*

  4) Oak Ridge[fn:oak: ~arXiv:2311.10687~ /TISCC: A Surface Code Compiler and Resource Estimator for Trapped-Ion Processors/] *Includes verification!* [[https://github.com/ORNL-QCI/TISCC][github.com/ORNL-QCI/TISCC]]

** Necessary reading: Later

  5) [@5] Fowler-Gidney[fn:FoGi: ~arXiv:1808.06709~ /Low overhead quantum computation using lattice surgery/ Fowler & Gidney]

  6) Litinski /Game of Surface Codes/

  7) Other Litinski stuff, e.g., on magic states.

** Other references

  * HFDM11[fn:HFDM11: ~arXiv:1111.4022~ /Surface code quantum computing by lattice surgery./ Horsman, Fowler,
    Devitt, Meter] Keep in mind that this paper is about the un-rotated surface code.

  * Sparse Blossom[fn:SparseBlossom: ~arXiv:2303:15933~ /Sparse Blossom: Correcting a million errors per
        core second with minimum-weight matching./ Higgot & Gidney] [[https://github.com/oscarhiggott/PyMatching][github.com/oscarhiggott/PyMatching]]

** Online discussions

  * Gidney-QCSX-CNOT [fn:GiCNOT: Gidney's answer on Quantum-Computing Stackexchange,
    [[https://quantumcomputing.stackexchange.com/questions/20830/how-can-surface-codes-perform-splitting-and-merging-at-the-same-time-when-they-i]]]

  * [[https://quantumcomputing.stackexchange.com/questions/38232/deformation-rules-for-zx-pipe-diagrams][Gidney's reply to /Deformation rules for ZX-pipe diagrams/.]]  DOT: Read this!

** EOF
# Local Variables:
# fill-column: 115
# End:
